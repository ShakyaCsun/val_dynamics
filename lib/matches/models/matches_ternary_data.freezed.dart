// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'matches_ternary_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$MatchesTernaryData {
  ({double aggro, double control, double midrange}) get stylePoints =>
      throw _privateConstructorUsedError;
  int get matchesCount => throw _privateConstructorUsedError;
  Score get score => throw _privateConstructorUsedError;
  Score get attackScore => throw _privateConstructorUsedError;
  Score get defenseScore => throw _privateConstructorUsedError;
  Set<AgentComp> get compositions => throw _privateConstructorUsedError;
  Set<AgentComp> get oppositionCompositions =>
      throw _privateConstructorUsedError;

  /// Create a copy of MatchesTernaryData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MatchesTernaryDataCopyWith<MatchesTernaryData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MatchesTernaryDataCopyWith<$Res> {
  factory $MatchesTernaryDataCopyWith(
    MatchesTernaryData value,
    $Res Function(MatchesTernaryData) then,
  ) = _$MatchesTernaryDataCopyWithImpl<$Res, MatchesTernaryData>;
  @useResult
  $Res call({
    ({double aggro, double control, double midrange}) stylePoints,
    int matchesCount,
    Score score,
    Score attackScore,
    Score defenseScore,
    Set<AgentComp> compositions,
    Set<AgentComp> oppositionCompositions,
  });
}

/// @nodoc
class _$MatchesTernaryDataCopyWithImpl<$Res, $Val extends MatchesTernaryData>
    implements $MatchesTernaryDataCopyWith<$Res> {
  _$MatchesTernaryDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MatchesTernaryData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stylePoints = null,
    Object? matchesCount = null,
    Object? score = null,
    Object? attackScore = null,
    Object? defenseScore = null,
    Object? compositions = null,
    Object? oppositionCompositions = null,
  }) {
    return _then(
      _value.copyWith(
            stylePoints:
                null == stylePoints
                    ? _value.stylePoints
                    : stylePoints // ignore: cast_nullable_to_non_nullable
                        as ({double aggro, double control, double midrange}),
            matchesCount:
                null == matchesCount
                    ? _value.matchesCount
                    : matchesCount // ignore: cast_nullable_to_non_nullable
                        as int,
            score:
                null == score
                    ? _value.score
                    : score // ignore: cast_nullable_to_non_nullable
                        as Score,
            attackScore:
                null == attackScore
                    ? _value.attackScore
                    : attackScore // ignore: cast_nullable_to_non_nullable
                        as Score,
            defenseScore:
                null == defenseScore
                    ? _value.defenseScore
                    : defenseScore // ignore: cast_nullable_to_non_nullable
                        as Score,
            compositions:
                null == compositions
                    ? _value.compositions
                    : compositions // ignore: cast_nullable_to_non_nullable
                        as Set<AgentComp>,
            oppositionCompositions:
                null == oppositionCompositions
                    ? _value.oppositionCompositions
                    : oppositionCompositions // ignore: cast_nullable_to_non_nullable
                        as Set<AgentComp>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$MatchesTernaryDataImplCopyWith<$Res>
    implements $MatchesTernaryDataCopyWith<$Res> {
  factory _$$MatchesTernaryDataImplCopyWith(
    _$MatchesTernaryDataImpl value,
    $Res Function(_$MatchesTernaryDataImpl) then,
  ) = __$$MatchesTernaryDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    ({double aggro, double control, double midrange}) stylePoints,
    int matchesCount,
    Score score,
    Score attackScore,
    Score defenseScore,
    Set<AgentComp> compositions,
    Set<AgentComp> oppositionCompositions,
  });
}

/// @nodoc
class __$$MatchesTernaryDataImplCopyWithImpl<$Res>
    extends _$MatchesTernaryDataCopyWithImpl<$Res, _$MatchesTernaryDataImpl>
    implements _$$MatchesTernaryDataImplCopyWith<$Res> {
  __$$MatchesTernaryDataImplCopyWithImpl(
    _$MatchesTernaryDataImpl _value,
    $Res Function(_$MatchesTernaryDataImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of MatchesTernaryData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stylePoints = null,
    Object? matchesCount = null,
    Object? score = null,
    Object? attackScore = null,
    Object? defenseScore = null,
    Object? compositions = null,
    Object? oppositionCompositions = null,
  }) {
    return _then(
      _$MatchesTernaryDataImpl(
        stylePoints:
            null == stylePoints
                ? _value.stylePoints
                : stylePoints // ignore: cast_nullable_to_non_nullable
                    as ({double aggro, double control, double midrange}),
        matchesCount:
            null == matchesCount
                ? _value.matchesCount
                : matchesCount // ignore: cast_nullable_to_non_nullable
                    as int,
        score:
            null == score
                ? _value.score
                : score // ignore: cast_nullable_to_non_nullable
                    as Score,
        attackScore:
            null == attackScore
                ? _value.attackScore
                : attackScore // ignore: cast_nullable_to_non_nullable
                    as Score,
        defenseScore:
            null == defenseScore
                ? _value.defenseScore
                : defenseScore // ignore: cast_nullable_to_non_nullable
                    as Score,
        compositions:
            null == compositions
                ? _value._compositions
                : compositions // ignore: cast_nullable_to_non_nullable
                    as Set<AgentComp>,
        oppositionCompositions:
            null == oppositionCompositions
                ? _value._oppositionCompositions
                : oppositionCompositions // ignore: cast_nullable_to_non_nullable
                    as Set<AgentComp>,
      ),
    );
  }
}

/// @nodoc

class _$MatchesTernaryDataImpl extends _MatchesTernaryData {
  const _$MatchesTernaryDataImpl({
    required this.stylePoints,
    required this.matchesCount,
    required this.score,
    required this.attackScore,
    required this.defenseScore,
    required final Set<AgentComp> compositions,
    required final Set<AgentComp> oppositionCompositions,
  }) : _compositions = compositions,
       _oppositionCompositions = oppositionCompositions,
       super._();

  @override
  final ({double aggro, double control, double midrange}) stylePoints;
  @override
  final int matchesCount;
  @override
  final Score score;
  @override
  final Score attackScore;
  @override
  final Score defenseScore;
  final Set<AgentComp> _compositions;
  @override
  Set<AgentComp> get compositions {
    if (_compositions is EqualUnmodifiableSetView) return _compositions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_compositions);
  }

  final Set<AgentComp> _oppositionCompositions;
  @override
  Set<AgentComp> get oppositionCompositions {
    if (_oppositionCompositions is EqualUnmodifiableSetView)
      return _oppositionCompositions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_oppositionCompositions);
  }

  @override
  String toString() {
    return 'MatchesTernaryData(stylePoints: $stylePoints, matchesCount: $matchesCount, score: $score, attackScore: $attackScore, defenseScore: $defenseScore, compositions: $compositions, oppositionCompositions: $oppositionCompositions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MatchesTernaryDataImpl &&
            (identical(other.stylePoints, stylePoints) ||
                other.stylePoints == stylePoints) &&
            (identical(other.matchesCount, matchesCount) ||
                other.matchesCount == matchesCount) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.attackScore, attackScore) ||
                other.attackScore == attackScore) &&
            (identical(other.defenseScore, defenseScore) ||
                other.defenseScore == defenseScore) &&
            const DeepCollectionEquality().equals(
              other._compositions,
              _compositions,
            ) &&
            const DeepCollectionEquality().equals(
              other._oppositionCompositions,
              _oppositionCompositions,
            ));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    stylePoints,
    matchesCount,
    score,
    attackScore,
    defenseScore,
    const DeepCollectionEquality().hash(_compositions),
    const DeepCollectionEquality().hash(_oppositionCompositions),
  );

  /// Create a copy of MatchesTernaryData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MatchesTernaryDataImplCopyWith<_$MatchesTernaryDataImpl> get copyWith =>
      __$$MatchesTernaryDataImplCopyWithImpl<_$MatchesTernaryDataImpl>(
        this,
        _$identity,
      );
}

abstract class _MatchesTernaryData extends MatchesTernaryData {
  const factory _MatchesTernaryData({
    required final ({double aggro, double control, double midrange})
    stylePoints,
    required final int matchesCount,
    required final Score score,
    required final Score attackScore,
    required final Score defenseScore,
    required final Set<AgentComp> compositions,
    required final Set<AgentComp> oppositionCompositions,
  }) = _$MatchesTernaryDataImpl;
  const _MatchesTernaryData._() : super._();

  @override
  ({double aggro, double control, double midrange}) get stylePoints;
  @override
  int get matchesCount;
  @override
  Score get score;
  @override
  Score get attackScore;
  @override
  Score get defenseScore;
  @override
  Set<AgentComp> get compositions;
  @override
  Set<AgentComp> get oppositionCompositions;

  /// Create a copy of MatchesTernaryData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MatchesTernaryDataImplCopyWith<_$MatchesTernaryDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
